# 절차지향과 객체지향의 차이
  - 절차지향 : 순차적인 처리를 중요시하고, 컴퓨터 처리 구조와 비슷하여 상대적으로 빠르지만 유지보수가 힘듬. 대표적으로 C언어가 해당됨
  - 객체지향 : 데이터와 동작을 묶어서 생각하며, 코드의 재사용과 유지보수가 쉽다는 장점이 있음. 절차지향에 비해 상대적으로 느리고 크기가 큼. 대표적으로 c++이 해당됨.
  
# struct(구조체)와 class의 차이
struct의 기본 접근제어 지시자는 public이고 class의 기본 접근제어 지시자는 private임.
  - public : 접근을 어디서든 허용
  - private : 접근을 class 내에서만 허용
  
# 오버로딩과 오버라이딩의 차이
  - 오버로딩 : 같은 이름의 함수를 매개변수를 다르게 하여 재정의 하는 방법 -> 매개변수 개수가 다르거나 개수가 같다면 매개변수의 타입이 달라야함.
  - 오버라이딩 : 상속 관계에서 클래스간 같은 이름, 같은 매개변수의 함수를 재정의하는 방법
  
# C++의 빌드 과정
전처리 -> 컴파일러 -> 어셈블러 -> 링커
  - 전처리 : #으로 시작하는 전처리기 구문 처리 및 주석 제거
  - 컴파일 : 어셈블리어(저수준 언어)로 변환
  - 어셈블 : 오브젝트 코드(0,1로 구성됨)로 변환
  - 링킹 : 라이브러리와 연결해 주고 실행 가능한 파일을 생성
  
# 얕은 복사와 깊은 복사의 차이
객체를 생성하고 초기화시킬 때 멤버변수를 어떻게 초기화하느냐에 따라 나뉨
  - 얕은 복사 : 실제 데이터가 아닌 단지 메모리 주소만을 복사
  - 깊은 복사 : 변수가 관리하는 리소스 자체를 복사하여 새롭게 멤버 변수에 입력시키는 것. 이 때 리소스 자체를 복사할 때 새롭게 메모리를 할당함.
  
# 동적 바인딩과 정적 바인딩
  - 정적 바인딩 : 컴파일 타임에 호출될 함수가 정해지는 것. 함수는 기본적으로 정적 바인딩
  - 동적 바인딩 : 런타임에 호출될 함수가 정해지는 것.
  
# Call by Value와 Call by Reference
  - Call by Value : 인자로 받는 값을 복사하여 처리하기 때문에 원래의 값은 보존되지만 메모리 사용량이 늘어남
  - Call by Refernce : 인자로 받는 값의 주소를 복사하여 처리하기 때문에 속도는 빠르지만 기존 값이 변경될 위험이 있음.
  
# 배열과 리스트(벡터)의 차이
   - 배열
    - 컴파일 할 때 크기가 결정됨 -> 크기가 고정되어 있으므로 원소의 데이터는 바꿀 수 있지만 원소를 추가하거나 삭제하는 것은 불가능
    - 스택메모리에 저장됨
    - 벡터에 비해 속도나 성능에서 우세함
  - 벡터
    - 삽입, 삭제가 이루어질때 동적으로 크기 변경
    - 벡터의 요소가 가득차면 현재 할당된 크기의 2배로 재할당 됨

# malloc과 new의 차이
malloc과 new 모두 동적할당을 하기 위해 사용된다. malloc은 c에서부터 사용되어온 것이고 new는 c++에 추가됨.
  - malloc -> free
    - 함수임
    - 초기화 불가능
  - new -> delete
    - 연산자임
    - 초기화 가능
객체의 경우 new를 사용하는 것이 맞지만, 재할당이 많이 일어나는 경우 malloc이 나은 경우도 있음 -> new의 경우 다시 할당해야 하지만 malloc의 경우 realloc을 통해 재할당이 간단히 이뤄짐.

# 입출력 속도를 높이는 법
c++의 경우 iostream과 stdio의 버퍼를 모두 사용해서 딜레이가 발생함. ios::sync_with_stdio(false)를 통해 c의 stdio 동기화를 끔으로써 실행속도를 높임.

# \n과 endl의 차이
둘다 개행을 위해 사용하지만 endl은 출력 버퍼를 비워주는 과정이 있어서 느림.
  - 버퍼 : 입출력을 프로그램에 바로 전달하지 않고 임시 메모리 공간에 저장한 후 한번에 전송

# 스마트 포인터
프로그래머의 실수로 인한 메모리 누수 문제를 해결하기 위해 등장함. 기존 포인터는 동적으로 할당한 메모리에 대해서 다 사용한 후 해제해야하는데 스마트 포인터는 해제에 대해 신경을 쓰지 않아도 됨.
