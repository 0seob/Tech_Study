# Creational Design Pattern
기존 코드의 유연성과 재사용을 증가시키는 객체를 생성하는 다양한 방법을 제공한다.
<br/>

## Factory Method
부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공한다. 하지만 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있다. 

### 사례
만약 물류 관리 어플리케이션을 제작할 때 `Truck`이라는 클래스에 모든 운송 관련 로직이 있다고 하자,
이 때 해상 관련 기능을 추가하기 위해 `Ship`이라는 클래스를 추가하려면 전체 코드 베이스를 수정해야한다. <br/>
또한 항공 관련 기능이나 다른 기능을 추가하는 등의 변경 사항에 대해 다시 전체 코드 베이스를 수정해야 하는 문제 가 있다. 

### 해결법
팩토리 메서드 패턴은 `new`를 사용한 객체 생성 직접 호출을 특별한 **팩토리** 메서드에 대한 호출로 대체한다.
여전히 객체는 `new`를 통해 생성 되지만 이는 팩토리에서 호출 된다. 또한 이를 통해 생성된 객체를 제품이라고 한다. 

![image](https://user-images.githubusercontent.com/29935137/210215108-f507ec2f-d0e4-4ae9-a473-d72792725a44.png)
<br/>

이 같은 변경 덕분에 이제 자식 클래스에서 팩토리 메서드를 오버라이딩하고 그 메서드에서 생성되는 제품의 클래스를 변경할 수 있다.

하지만, 이 방법도 제한이 있다. 자식 클래스는 다른 유형의 제품을 해당 제품들이 공통 기초 클래스 또는 인터페이스가 
있는 경우에만 반환할 수 있다. `Transport`인터페이스로 `Logistics` 클래스의 `createTransport`팩토리 메서드 반환 유형을 선언해야 한다.

![image](https://user-images.githubusercontent.com/29935137/210216840-aec718d9-3c94-4ba7-834a-d7d169ea9a88.png)

위 사례의 `Truck`과 `Ship` 클래스 모두 `Transport` 인터페이스를 구현해야 하며, 이 인터페이스는 `deliver`라는 메서드를 선언해야한다. <br/>
그러나 각 클래스는 이 메서드를 다르게 구현하게 된다. `RoadLogistics` 클래스에 포함된 팩토리 메서드는 `Truck` 객체를 반환하고, <br/>
`SeaLogistics` 클래스에 포함된 팩토리 메서드는 `Ship` 객체를 반환하게 된다. 

이 과정에서 물류 관리 앱은 여러 제품의 차이를 알지 못하고, 모든 제품을 추상 `Transport`로 간주하여 동작한다.

### 적용
**Q1.** 코드가 함께 작동해야 하는 객체들의 정확한 유형과 의존관계들을 미리 모르는 경우 <br/>
**A1.** 팩토리 메서드는 제품 생성 코드를 제품을 실제로 사용하는 코드와 분리한다. 따라서 제품 생성자 코드를 나머지 코드와 독립적으로 확장할 하기 쉽다.<br/>
<br/>
**Q2.** 라이브러리 또는 프레임워크의 사용자들에게 내부 컴포넌트를 확장하는 방법을 제공할 때 <br/>
**A2.** 프레임워크 전체에서 컴포넌트들을 생성하는 코드를 단일 패토리 맥서드로 줄인 후, 누구나 이 팩토리 메서드를 오버라이드 할 수 있도록 한다.<br/>
<br/>
**Q3** 기즌 객체들을 매번 재구축하는 대신 이들을 재사용하여 시스템 리소스를 절약하고 싶을 때<br/>
**A3** 데이터베이스 연결, 파일 시스템, 네트워크와 같은 시스템 자원을 많이 사용하는 대규모 객체를 처리할 때 사용하며, 이 코드는 주로 생성자에 위치한다.<br/>
그러나 생성자는 항상 새로운 객체들을 반환해야 하며, 기존 인스턴스는 반환할 수 없다. 따라서 새 객체들을 생성하고 기존 객체를 재사용할 수 있는 일반적인 메서드가 필요하다.<br/>
<br/>



### 장단점
|장점|단점|
|:-:|:-:|
|크리에이터와 구상 제품들이 단단하게 결합되지 않도록 할 수 있다|패턴을 구현하기 위해 많은 새로운 자식 클래스들을 도입해야 하므로 코드가 더 복잡해질 수 있습니다. 가장 좋은 방법은 크리에이터 클래스들의 기존 계층구조에 패턴을 도입하는 것이다.|
|단일 책임 원칙. 제품 생성 코드를 프로그램의 한 위치로 이동하여 코드를 더 쉽게 유지관리할 수 있다||
|개방/폐쇄 원칙. 당신은 기존 클라이언트 코드를 훼손하지 않고 새로운 유형의 제품들을 프로그램에 도입할 수 있다||


## Singletone

## Abtract Factory

## Builder

## Prototype
